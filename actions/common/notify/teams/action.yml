name: "Notify Deployment Teams"
description: "Send deployment notification to Microsoft Teams"

inputs:
  type:
    description: "Notification type label (e.g. deploy, rollback, hotfix)"
    required: true
  webhook-url:
    description: "Teams webhook URL"
    required: true
  deployment-url:
    description: "CloudFront domain for deployment URL"
    required: true
  payload:
    description: "Optional JSON payload to merge or append to the default message"
    required: false
  issue-link-pattern:
    description: "Pattern to turn issue keys into links. Use ${id} as the placeholder."
    required: false
  issue-summary-pattern:
    description: "Pattern for fetching Jira issue details. Use ${id} as the placeholder."
    required: false
  environment:
    description: "Environment label to display in the notification"
    required: false
  category:
    description: "Category label to include alongside the notification details"
    required: false

runs:
  using: "composite"
  steps:
    - name: Checkout code
      uses: actions/checkout@v5
      with:
        fetch-depth: 0
        persist-credentials: false

    - name: Resolve commit info
      id: commit
      shell: bash
      env:
        ISSUE_LINK_PATTERN: ${{ inputs.issue-link-pattern }}
        ISSUE_SUMMARY_PATTERN: ${{ inputs.issue-summary-pattern }}
      run: |
        if [ "${{ github.ref_type }}" = "tag" ]; then
          COMMIT_SHA="$(git rev-list -n 1 $GITHUB_REF_NAME)"
        else
          COMMIT_SHA="${GITHUB_SHA}"
        fi
        COMMIT_SUBJECT="$(git show -s --format=%s "$COMMIT_SHA")"
        echo "sha=$COMMIT_SHA" >> "$GITHUB_OUTPUT"
        echo "subject<<EOF" >> "$GITHUB_OUTPUT"
        echo "$COMMIT_SUBJECT" >> "$GITHUB_OUTPUT"
        echo "EOF" >> "$GITHUB_OUTPUT"

        CHANGELOG_NOTES=""
        if git show "$COMMIT_SHA:CHANGELOG.md" >/dev/null 2>&1; then
          CHANGELOG_DIFF="$(git diff "${COMMIT_SHA}^" "$COMMIT_SHA" -- CHANGELOG.md || true)"
          CHANGELOG_NOTES="$(
            printf '%s\n' "$CHANGELOG_DIFF" | awk '
              /^\+\+\+/ {next}
              !/^\+/ {next}
              {
                ISSUE_SUMMARIES=""
                if [ -n "$ISSUE_SUMMARY_PATTERN" ] && [ -n "$CHANGELOG_NOTES" ]; then
                  SUMMARY_SCRIPT="$(mktemp)"
                  cat <<'NODE' > "$SUMMARY_SCRIPT"
        const pattern = process.env.ISSUE_SUMMARY_PATTERN || "";
        const linkPattern = process.env.ISSUE_LINK_PATTERN || "";
        const changelog = process.env.CHANGELOG_CONTENT || "";

        const issueRegex = /\*\*\[?([A-Z][A-Z0-9]+-\d+)/g;
        const ids = Array.from(new Set(Array.from(changelog.matchAll(issueRegex), match => match[1])));

        if (!pattern || ids.length === 0) {
          process.exit(0);
        }

        const buildLink = (template, id) => template.replace(/\$\{id\}/g, encodeURIComponent(id));

        const toLine = (id, data) => {
          if (!data || !data.fields || !data.fields.summary) return null;
          const summary = data.fields.summary;
          const status = data.fields.status && data.fields.status.name ? data.fields.status.name : "";
          const type = data.fields.issuetype && data.fields.issuetype.name ? data.fields.issuetype.name : "";
          const label = linkPattern ? `[${id}](${buildLink(linkPattern, id)})` : id;
          const extras = [status, type].filter(Boolean).join(" · ");
          return `* **${label}** — ${summary}${extras ? ` (${extras})` : ""}`;
        };

        const fetchIssue = async (id) => {
          try {
            const url = buildLink(pattern, id);
            const response = await fetch(url, {
              headers: {
                'Accept': 'application/json',
                'User-Agent': 'github-actions-teams-notify'
              }
            });
            if (!response.ok) {
              console.error(`Failed to fetch ${id}: ${response.status}`);
              return null;
            }
            const data = await response.json();
            return toLine(id, data);
          } catch (error) {
            console.error(`Failed to fetch ${id}: ${error.message}`);
            return null;
          }
        };

        (async () => {
          const results = await Promise.all(ids.map(fetchIssue));
          const lines = results.filter(Boolean);
          if (lines.length) {
            process.stdout.write(lines.join("\n"));
          }
        })().catch(error => {
          console.error(`Issue summary aggregation failed: ${error.message}`);
          process.exit(1);
        });
          echo "changelog<<EOF" >> "$GITHUB_OUTPUT"
                  ISSUE_SUMMARIES="$(ISSUE_SUMMARY_PATTERN="$ISSUE_SUMMARY_PATTERN" ISSUE_LINK_PATTERN="$ISSUE_LINK_PATTERN" CHANGELOG_CONTENT="$CHANGELOG_NOTES" node "$SUMMARY_SCRIPT")"
                  rm -f "$SUMMARY_SCRIPT"
          printf '%s\n' "$CHANGELOG_NOTES" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
        fi

        ISSUE_SUMMARIES=""
        if [ -n "$ISSUE_SUMMARY_PATTERN" ] && [ -n "$CHANGELOG_NOTES" ]; then
          ISSUE_SUMMARIES="$(ISSUE_SUMMARY_PATTERN="$ISSUE_SUMMARY_PATTERN" ISSUE_LINK_PATTERN="$ISSUE_LINK_PATTERN" CHANGELOG_CONTENT="$CHANGELOG_NOTES" node <<'NODE'
            const pattern = process.env.ISSUE_SUMMARY_PATTERN || "";
            const linkPattern = process.env.ISSUE_LINK_PATTERN || "";
            const changelog = process.env.CHANGELOG_CONTENT || "";

            const issueRegex = /\*\*\[?([A-Z][A-Z0-9]+-\d+)/g;
            const ids = Array.from(new Set(Array.from(changelog.matchAll(issueRegex), match => match[1])));

            if (!pattern || ids.length === 0) {
              process.exit(0);
            }

            const buildLink = (template, id) => template.replace(/\$\{id\}/g, encodeURIComponent(id));

            const toLine = (id, data) => {
              if (!data || !data.fields || !data.fields.summary) return null;
              const summary = data.fields.summary;
              const status = data.fields.status && data.fields.status.name ? data.fields.status.name : "";
              const type = data.fields.issuetype && data.fields.issuetype.name ? data.fields.issuetype.name : "";
              const label = linkPattern ? `[${id}](${buildLink(linkPattern, id)})` : id;
              const extras = [status, type].filter(Boolean).join(" · ");
              return `* **${label}** — ${summary}${extras ? ` (${extras})` : ""}`;
            };

            const fetchIssue = async (id) => {
              try {
                const url = buildLink(pattern, id);
                const response = await fetch(url, {
                  headers: {
                    'Accept': 'application/json',
                    'User-Agent': 'github-actions-teams-notify'
                  }
                });
                if (!response.ok) {
                  console.error(`Failed to fetch ${id}: ${response.status}`);
                  return null;
                }
                const data = await response.json();
                return toLine(id, data);
              } catch (error) {
                console.error(`Failed to fetch ${id}: ${error.message}`);
                return null;
              }
            };

            (async () => {
              const results = await Promise.all(ids.map(fetchIssue));
              const lines = results.filter(Boolean);
              if (lines.length) {
                process.stdout.write(lines.join("\n"));
              }
            })().catch(error => {
              console.error(`Issue summary aggregation failed: ${error.message}`);
            });
          NODE
          )"
        fi

        if [ -n "$ISSUE_SUMMARIES" ]; then
          echo "tickets<<EOF" >> "$GITHUB_OUTPUT"
          printf '%s\n' "$ISSUE_SUMMARIES" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
        fi

    - name: Send Teams notification
      shell: bash
      env:
        TEAMS_WEBHOOK_URL: ${{ inputs.webhook-url }}
        DEPLOYMENT_URL: ${{ inputs.deployment-url }}
        TYPE: ${{ inputs.type }}
        CUSTOM_PAYLOAD: ${{ inputs.payload }}
        JOB_ENVIRONMENT: ${{ github.environment.name }}
        INPUT_ENVIRONMENT: ${{ inputs.environment }}
        INPUT_CATEGORY: ${{ inputs.category }}
        TICKET_SUMMARIES: ${{ steps.commit.outputs.tickets }}
        CHANGELOG_NOTES: ${{ steps.commit.outputs.changelog }}
        REPOSITORY_FULL_NAME: ${{ github.repository }}
      run: |
        TAG="${GITHUB_REF_NAME}"
        BASE_URL="${DEPLOYMENT_URL%/}"
        URL=""
        if [ -n "${BASE_URL}" ]; then
          URL="${BASE_URL}/${TAG}/"
        fi

        TYPE_RAW="${TYPE:-deploy}"
        TYPE_LABEL="$(printf '%s' "$TYPE_RAW" | tr '[:upper:]' '[:lower:]')"
        TYPE_DISPLAY="${TYPE_LABEL^}"
        TITLE_VALUE="${TYPE_DISPLAY} ${TAG}"
        ENVIRONMENT_LABEL="${INPUT_ENVIRONMENT:-${JOB_ENVIRONMENT:-}}"
        CATEGORY_LABEL="${INPUT_CATEGORY:-}"
        TICKETS_VALUE="${TICKET_SUMMARIES:-}"

        REPO_NAME="${REPOSITORY_FULL_NAME##*/}"

        case "${TYPE_LABEL}" in
          rollback|hotfix|incident)
            THEME_COLOR="d73a49"
            ;;
          promote|deploy)
            THEME_COLOR="28a745"
            ;;
          *)
            THEME_COLOR="6c5ce7"
            ;;
        esac

        payload=$(jq -n \
          --arg title       "$TITLE_VALUE" \
          --arg url         "$URL" \
          --arg repository  "$REPO_NAME" \
          --arg sha         "${{ steps.commit.outputs.sha }}" \
          --arg actor       "${{ github.actor }}" \
          --arg msg         "${{ steps.commit.outputs.subject }}" \
          --arg color       "$THEME_COLOR" \
          --arg notifyType  "$TYPE_DISPLAY" \
          --arg environment "$ENVIRONMENT_LABEL" \
          --arg notes       "$CHANGELOG_NOTES" \
          --arg tickets     "$TICKETS_VALUE" \
          --arg category    "$CATEGORY_LABEL" \
          '{
            "@type":"MessageCard",
            "@context":"https://schema.org/extensions",
            "themeColor":$color,
            "summary":($notifyType + " notification" + (if ($environment|length) > 0 then " (" + $environment + ")" else "" end)),
            "title": ($notifyType + ": " + $title + (if ($environment|length) > 0 then " · " + $environment else "" end)),
            "sections": (
              [{
                "facts": (
                  [
                    {"name":"Type","value":$notifyType}
                  ]
                  + (if ($category|length) > 0 then [{"name":"Category","value":$category}] else [] end)
                  + [
                    {"name":"Repository","value":$repository},
                    {"name":"Commit","value":$sha},
                    {"name":"Message","value":$msg},
                    {"name":"Actor","value":$actor}
                  ]
                  + (if ($environment|length) > 0 then [{"name":"Environment","value":$environment}] else [] end)
                  + (if ($url|length) > 0 then [{"name":"URL","value":$url}] else [] end)
                )
              }]
              + (if ($notes|length) > 0 then [{
                "title":"Changelog",
                "text":$notes
              }] else [] end)
              + (if ($tickets|length) > 0 then [{
                "title":"Jira Tickets",
                "text":$tickets
              }] else [] end)
            ),
            "potentialAction": (
              if ($url|length) > 0 then [{
                "@type":"OpenUri",
                "name":"Open Deployment",
                "targets":[{"os":"default","uri":$url}]
              }] else [] end
            )
          }')

        if [ -n "$CUSTOM_PAYLOAD" ]; then
          if payload_json=$(printf '%s' "$CUSTOM_PAYLOAD" | jq -c . 2>/dev/null); then
            payload=$(jq -n \
              --argjson base "$payload" \
              --argjson custom "$payload_json" \
              'def deepmerge($a; $b):
                reduce ($b | keys_unsorted[]) as $key ($a;
                  if ($a[$key] // null) | type == "object" and ($b[$key] | type) == "object" then
                    .[$key] = deepmerge($a[$key]; $b[$key])
                  else
                    .[$key] = $b[$key]
                  end);
               deepmerge($base; $custom)')
          else
            payload=$(jq -n \
              --argjson base "$payload" \
              --arg extra "$CUSTOM_PAYLOAD" \
              '$base | .sections += [{"activityTitle":"Additional Details","text":$extra}]')
          fi
        fi

        curl -sS -X POST -H 'Content-Type: application/json' \
          -d "$payload" "$TEAMS_WEBHOOK_URL"

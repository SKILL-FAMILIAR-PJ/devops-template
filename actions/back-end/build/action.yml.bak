name: ci-cd-backend-build
description: "Build action (parameterized): determine env optionally, build & push image, produce outputs"
runs:
  using: "composite"
  steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Cache Docker layers
      uses: actions/cache@v4
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-buildx-${{ inputs.ecr_repository }}-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-${{ inputs.ecr_repository }}-
          ${{ runner.os }}-buildx-

    - name: Cache dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.m2/repository
          ~/.gradle/caches
          ~/.npm
          node_modules
        key: ${{ runner.os }}-deps-${{ hashFiles('**/pom.xml', '**/build.gradle', '**/package-lock.json', '**/yarn.lock') }}
        restore-keys: |
          ${{ runner.os }}-deps-

    - name: (Optional) Determine target environment
      id: determine_env
      shell: bash
      if: ${{ inputs.determine_env == 'true' }}
      run: |
        INPUT_ENV="${{ inputs.input_env || '' }}"
        BRANCH="${GITHUB_REF#refs/heads/}"
        if [ -n "$INPUT_ENV" ]; then
          TARGET="$INPUT_ENV"
        else
          if [ "$BRANCH" = "develop" ]; then TARGET="dev"
          elif [ "$BRANCH" = "staging" ]; then TARGET="stg"
          elif [ "$BRANCH" = "main" ] || [ "$BRANCH" = "master" ]; then TARGET="prd"
          else TARGET="dev"; fi
        fi
        echo "target_env=${TARGET}" >> $GITHUB_OUTPUT

    - name: Compute & push tag
      id: create_tag
      shell: bash
      env:
        SEMVER_BASE: ${{ inputs.semver_base }}
        MAX_TAG_RETRIES: ${{ inputs.max_tag_retries }}
        GITHUB_TOKEN: ${{ inputs.github_token }}
      run: |
        set -euo pipefail
         git config user.email "actions@github.com"
         git config user.name "GitHub Actions"
         REPO_URL="https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git"
         git remote set-url origin "$REPO_URL"
         git fetch --prune --unshallow --tags origin || git fetch --prune --tags origin || true

         BRANCH="${GITHUB_REF#refs/heads/}"
         BASE="${SEMVER_BASE}"
         if [ "$BRANCH" = "develop" ]; then
           PREFIX="${BASE}-DEV."
         elif [ "$BRANCH" = "main" ] || [ "$BRANCH" = "master" ]; then
           PREFIX="${BASE}-PRD."
         else
           echo "created=false" >> $GITHUB_OUTPUT
           exit 0
         fi

         RETRIES=${MAX_TAG_RETRIES}
         i=0
         while [ $i -lt $RETRIES ]; do
           i=$((i+1))
           git fetch --tags --prune origin
           MAX=0
           TAGS=$(git tag -l "${PREFIX}*")
           if [ -n "$TAGS" ]; then
             while read -r t; do
               num=${t##*.}
               if [[ $num =~ ^[0-9]+$ ]]; then
                 if (( num > MAX )); then
                   MAX=$num
                 fi
               fi
             done <<< "$TAGS"
           fi

           NEXT=$((MAX + 1))
           NEW_TAG="${PREFIX}${NEXT}"
           if git tag -a "$NEW_TAG" -m "Auto tag $NEW_TAG by $GITHUB_ACTOR on ${GITHUB_REF}" 2>/tmp/git_tag_err || true; then
             :
           else
             git tag "$NEW_TAG"
           fi
           if git push origin "refs/tags/${NEW_TAG}"; then
             echo "created=true" >> $GITHUB_OUTPUT
             echo "new_tag=${NEW_TAG}" >> $GITHUB_OUTPUT
             exit 0
           else
             git tag -d "$NEW_TAG" || true
             sleep 1
           fi
         done

         echo "created=false" >> $GITHUB_OUTPUT
         exit 1

    - name: Set IMAGE_TAG
      id: image_tag
      shell: bash
      run: |
        if [ "${{ steps.create_tag.outputs.created }}" = "true" ]; then
          echo "image_tag=${{ steps.create_tag.outputs.new_tag }}" >> $GITHUB_OUTPUT
        else
          SHA=$(git rev-parse --short HEAD)
          TAG="${{ inputs.semver_base }}-SNAP.${SHA}"
          echo "image_tag=${TAG}" >> $GITHUB_OUTPUT
        fi

    - name: Compute IMAGE_URI
      id: compute_image_uri
      shell: bash
      run: |
        IMAGE_URI="${{ inputs.ecr_account_id }}.dkr.ecr.${{ inputs.aws_region }}.amazonaws.com/${{ inputs.ecr_repository }}:${{ steps.image_tag.outputs.image_tag }}"
        echo "image_uri=${IMAGE_URI}" >> $GITHUB_OUTPUT

    - name: Configure AWS via OIDC
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ inputs.oidc_role_arn }}
        aws-region: ${{ inputs.aws_region }}

    - name: Ensure ECR repo exists
      shell: bash
      run: |
        REPO="${{ inputs.ecr_repository }}"
        aws ecr describe-repositories --repository-names "${REPO}" --region "${{ inputs.aws_region }}" >/dev/null 2>&1 || aws ecr create-repository --repository-name "${REPO}" --region "${{ inputs.aws_region }}" || true

    - name: Login to ECR
      shell: bash
      run: aws ecr get-login-password --region ${{ inputs.aws_region }} | docker login --username AWS --password-stdin ${{ inputs.ecr_account_id }}.dkr.ecr.${{ inputs.aws_region }}.amazonaws.com

    - name: Set up Docker Buildx (use docker-container builder)
      uses: docker/setup-buildx-action@v2
      with:
        driver: docker-container
        install: true

    - name: Build & push
      uses: docker/build-push-action@v4
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: ${{ steps.compute_image_uri.outputs.image_uri }}
        # platforms: linux/amd64
        target: ${{ inputs.build_target }}
        build-args: |
          GITHUB_USERNAME=${{ github.actor }}
          CI_WORKER_REPOSITORY_TOKEN=${{ inputs.packages_token }}
        cache-from: |
          type=gha
          type=local,src=/tmp/.buildx-cache
        cache-to: |
          type=gha,mode=max
          type=local,dest=/tmp/.buildx-cache-new,mode=max
        pull: true
        provenance: false
        sbom: false

    - name: Move cache
      shell: bash
      run: |
        rm -rf /tmp/.buildx-cache
        mv /tmp/.buildx-cache-new /tmp/.buildx-cache || true

    - name: Prepare SSM path info (no secret values)
      id: prepare_ssm
      shell: bash
      run: |
        PARAM_PATH="${{ inputs.param_path || '/' }}${{ steps.determine_env.outputs.target_env || '' }}"
        echo "param_path=${PARAM_PATH}" >> $GITHUB_OUTPUT

outputs:
  image_uri:
    value: ${{ steps.compute_image_uri.outputs.image_uri }}
    description: "Full ECR image URI"
  image_tag:
    value: ${{ steps.image_tag.outputs.image_tag }}
    description: "Image tag used for the build"
  param_path:
    value: ${{ steps.prepare_ssm.outputs.param_path }}
    description: "SSM Parameter Store base path (no secret values)"

inputs:
  determine_env:
    required: false
    default: "false"
    description: "Whether to determine target environment based on branch"
  input_env:
    required: false
    description: "Explicit target environment (overrides branch-based determination)"
  github_token:
    required: true
    description: "GitHub token for authentication"
  packages_token:
    required: true
    description: "GitHub token for authentication"
  oidc_role_arn:
    required: true
    description: "OIDC role ARN for AWS"
  ecr_account_id:
    required: true
    description: "ECR account ID"
  aws_region:
    required: true
    description: "AWS region"
  ecr_repository:
    required: true
    description: "ECR repository name"
  semver_base:
    required: true
    description: "Base semantic version"
  max_tag_retries:
    required: true
    description: "Maximum number of retries for tag creation"
  param_path:
    required: false
    description: "Base SSM Parameter Store path prefix"
  build_target:
    required: false
    description: "Docker build target"

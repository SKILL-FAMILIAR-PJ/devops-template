name: ci-cd-backend-release
description: "Release action: register task definition and update ECS service"
runs:
  using: "composite"
  steps:
    - name: Configure AWS via OIDC
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ inputs.oidc_role_arn }}
        aws-region: ${{ inputs.aws_region }}

    - name: Build container-defs.json (env & secrets)
      id: build_defs
      shell: bash
      run: |
        set -euo pipefail

        # Inputs
        AWS_REGION="${{ inputs.aws_region }}"
        ACCOUNT="${{ inputs.ecr_account_id }}"
        PARAM_PATH="${{ inputs.param_path }}"
        APP_PORT="${{ inputs.app_port }}"
        IMAGE_URI="${{ inputs.image_uri }}"
        SERVICE_NAME="${{ inputs.service_name }}"
        LOG_GROUP="${{ inputs.log_group }}"
        PORT_MAPPINGS_NAME="${{ inputs.service_name }}"
        APP_CORS_ALLOWED_ORIGINS="${{ inputs.app_cors_allowed_origins }}"
        GRPC_CLIENT_AUTH_ADDRESS="${{ inputs.grpc_client_auth_address }}"
        GRPC_CLIENT_DIRECTORY_ADDRESS="${{ inputs.grpc_client_directory_address }}"
        GRPC_CLIENT_NOTIFICATION_ADDRESS="${{ inputs.grpc_client_notification_address }}"

        PARAM_PATH="${PARAM_PATH:-/dev}"
        APP_CORS_ALLOWED_ORIGINS="${APP_CORS_ALLOWED_ORIGINS:-}"

        ALLOWED_INPUT="${{ inputs.allowed_env_vars}}"
        declare -A ALLOWED_SET
        if [ -n "$ALLOWED_INPUT" ]; then
          # trim spaces and split by comma
          IFS=',' read -r -a tmp_arr <<< "$(echo "$ALLOWED_INPUT" | sed 's/[[:space:]]//g')"
          for k in "${tmp_arr[@]}"; do
            if [ -n "$k" ]; then
              ALLOWED_SET["$k"]=1
            fi
          done
        fi

        echo "[]" > env_nonsecret.json
        append_if_set() {
          local key="$1"; shift
          local val="$1"
          if [ -n "$val" ]; then
            jq --arg name "$key" --arg value "$val" '. + [{name:$name, value:$value}]' env_nonsecret.json > /tmp/env.json && mv /tmp/env.json env_nonsecret.json
          fi
        }

        append_if_set "PROVIDER_AWS_REGION" "$AWS_REGION"
        append_if_set "GRPC_SERVER_PORT" "$APP_PORT"
        append_if_set "APP_CORS_ALLOWED_ORIGINS" "$APP_CORS_ALLOWED_ORIGINS"
        append_if_set "GRPC_CLIENT_AUTH_ADDRESS" "$GRPC_CLIENT_AUTH_ADDRESS"
        append_if_set "GRPC_CLIENT_DIRECTORY_ADDRESS" "$GRPC_CLIENT_DIRECTORY_ADDRESS"
        append_if_set "GRPC_CLIENT_NOTIFICATION_ADDRESS" "$GRPC_CLIENT_NOTIFICATION_ADDRESS"

        # Allow observability and framework env vars to be passed via the step environment.
        PASSTHROUGH_ENV_VARS=(
          "OTEL_SERVICE_NAME"
          "OTEL_EXPORTER_OTLP_ENDPOINT"
          "OTEL_EXPORTER_OTLP_PROTOCOL"
          "OTEL_TRACES_EXPORTER"
          "OTEL_METRICS_EXPORTER"
          "OTEL_LOGS_EXPORTER"
          "OTEL_RESOURCE_ATTRIBUTES"
          "OTEL_TRACES_SAMPLER"
          "OTEL_TRACES_SAMPLER_ARG"
          "OTEL_INSTRUMENTATION_LOGGING_MDC_INJECTION"
          "OTEL_INSTRUMENTATION_COMMON_SUPPRESS_HTTP_URL_PARAMETERS"
          "OTEL_EXPORTER_OTLP_TIMEOUT"
          "OTEL_EXPORTER_OTLP_COMPRESSION"
          "SPRING_PROFILES_ACTIVE"
          "APP_PORT"
        )

        for VAR in "${PASSTHROUGH_ENV_VARS[@]}"; do
          VALUE="${!VAR:-}"
          append_if_set "$VAR" "$VALUE"
        done

        echo "env_nonsecret.json contents:"
        cat env_nonsecret.json || true

        declare -A SSM_MAP
        SSM_MAP["PROVIDER_POSTGRES_URL"]="rds/url"
        SSM_MAP["PROVIDER_POSTGRES_USERNAME"]="rds/username"
        SSM_MAP["PROVIDER_POSTGRES_PASSWORD"]="rds/password"
        SSM_MAP["PROVIDER_AWS_COGNITO_CLIENT_ID"]="cognito/app-client-id"
        SSM_MAP["PROVIDER_AWS_COGNITO_CLIENT_SECRET"]="cognito/app-client-secret"
        SSM_MAP["PROVIDER_AWS_COGNITO_USER_POOL_ID"]="cognito/user-pool-id"
        SSM_MAP["CLOUDFRONT_WEB_ID"]="cloudfront/web-id"
        SSM_MAP["PROVIDER_AWS_ACCESS_KEY_ID"]="iam/read-only-access-key-id"
        SSM_MAP["PROVIDER_AWS_SECRET_ACCESS_KEY"]="iam/read-only-secret-access-key"
        SSM_MAP["PROVIDER_AWS_ACCOUNT_ID"]="iam/account-id"
        SSM_MAP["PROVIDER_KAFKA_BOOTSTRAP_SERVER"]="kafka/nlb-endpoint"
        SSM_MAP["PROVIDER_REDIS_HOST"]="redis/nlb-endpoint"
        SSM_MAP["PROVIDER_REDIS_PORT"]="redis/port"
        SSM_MAP["PROVIDER_REDIS_PASSWORD"]="redis/password"
        SSM_MAP["PROVIDER_REDIS_USERNAME"]="redis/user"
        SSM_MAP["APP_FRONTEND_ORIGIN_ROOT"]="cloudfront/origin-root"

        echo "[]" > secrets.json
        for VAR in "${!SSM_MAP[@]}"; do
          if [ "${#ALLOWED_SET[@]}" -gt 0 ]; then
            if [ -z "${ALLOWED_SET[$VAR]:-}" ]; then
              continue
            fi
          else
            continue
          fi

          SUFFIX="${SSM_MAP[$VAR]}"
          ARN="arn:aws:ssm:${AWS_REGION}:${ACCOUNT}:parameter${PARAM_PATH}/${SUFFIX}"
          jq --arg n "$VAR" --arg v "$ARN" '. + [{"name":$n,"valueFrom":$v}]' secrets.json > /tmp/secrets.json && mv /tmp/secrets.json secrets.json
        done

        echo "secrets.json summary:"
        jq -r '.[].name' secrets.json | sed -e 's/^/SECRET: /' || true
        APP_PORT_NUM="${APP_PORT}"
        cat > container-defs.json <<EOF
        [
          {
            "name": "${SERVICE_NAME}",
            "image": "${IMAGE_URI}",
            "essential": true,
            "portMappings": [
              {
                "containerPort": ${APP_PORT_NUM},
                "hostPort": ${APP_PORT_NUM},
                "protocol": "tcp",
                "name": "${PORT_MAPPINGS_NAME}"
              }
            ],
            "logConfiguration": {
              "logDriver": "awslogs",
              "options": {
                "awslogs-group": "${LOG_GROUP}",
                "awslogs-region": "${AWS_REGION}",
                "awslogs-stream-prefix": "${SERVICE_NAME}"
              }
            },
            "environment": $(cat env_nonsecret.json),
            "secrets": $(cat secrets.json)
          }
        ]
        EOF

        jq '.[0] | {name: .name, image: .image, portMappings: .portMappings, logConfiguration: .logConfiguration, environment: .environment, secrets: [.secrets[].name] }' container-defs.json || true

        echo "container_defs_ready=true" >> $GITHUB_OUTPUT
        echo "container_defs_path=container-defs.json" >> $GITHUB_OUTPUT

    - name: Register Task Definition
      id: register_task
      shell: bash
      run: |
        set -euo pipefail
        if [ ! -f container-defs.json ]; then
          echo "ERROR: container-defs.json not found"
          ls -la
          exit 2
        fi

        TASK_DEF_ARN=$(aws ecs register-task-definition \
          --family "${{ inputs.service_name }}" \
          --requires-compatibilities FARGATE \
          --network-mode awsvpc \
          --cpu "${{ inputs.ecs_task_cpu }}" \
          --memory "${{ inputs.ecs_task_memory }}" \
          --runtime-platform "cpuArchitecture=${{ inputs.cpu_arch }},operatingSystemFamily=${{ inputs.os_family }}" \
          --execution-role-arn "${{ inputs.ecs_task_execution_role_arn }}" \
          --task-role-arn "${{ inputs.ecs_task_execution_role_arn }}" \
          --container-definitions file://container-defs.json \
          --query 'taskDefinition.taskDefinitionArn' --output text --region "${{ inputs.aws_region }}")
        echo "new_taskdef_arn=${TASK_DEF_ARN}" >> $GITHUB_OUTPUT

    - name: Update Service (force new deployment)
      shell: bash
      run: |
        aws ecs update-service --cluster "${{ inputs.ecs_cluster }}" --service "${{ inputs.service_name }}" --task-definition "${{ steps.register_task.outputs.new_taskdef_arn }}" --force-new-deployment --region "${{ inputs.aws_region }}"
        echo "service_updated=true" >> $GITHUB_OUTPUT

inputs:
  oidc_role_arn:
    description: "OIDC role ARN assumed for AWS operations"
    required: true
  aws_region:
    description: "AWS region for ECS and SSM operations"
    required: true
  ecr_account_id:
    description: "AWS account ID that hosts the container image"
    required: true
  param_path:
    description: "Base SSM path prefix (e.g. /dev)"
    required: false
  image_uri:
    description: "Full image URI pushed to ECR"
    required: true
  service_name:
    description: "ECS service name to update"
    required: true
  ecs_cluster:
    description: "ECS cluster name"
    required: true
  log_group:
    description: "CloudWatch log group used by the task"
    required: true
  app_port:
    description: "Container port to expose"
    required: true
  provider_aws_influxdb_token:
    description: "Legacy input reserved for compatibility"
    required: false
  ecs_task_execution_role_arn:
    description: "Task execution role ARN"
    required: true
  ecs_task_cpu:
    description: "Task CPU units"
    required: true
  ecs_task_memory:
    description: "Task memory in MiB"
    required: true
  cpu_arch:
    description: "Task CPU architecture"
    required: true
  os_family:
    description: "Task operating system family"
    required: true
  app_cors_allowed_origins:
    description: "Allowed origins for CORS (optional)"
    required: false
  allowed_env_vars:
    description: "Comma-separated list of secret names permitted for SSM injection"
    required: false
  grpc_client_auth_address:
    description: "Optional gRPC auth service endpoint"
    required: false
  grpc_client_directory_address:
    description: "Optional gRPC directory service endpoint"
    required: false
  grpc_client_notification_address:
    description: "Optional gRPC notification service endpoint"
    required: false

outputs:
  new_taskdef_arn:
    description: "ARN of the registered task definition"
    value: ${{ steps.register_task.outputs.new_taskdef_arn }}
